= Gestion des données d'entrée
ifndef::backend-pdf[]
:imagesdir: images
endif::[]

Conformément à l'architecture applicative, c'est une méthode dite _contrôleur_ qui prend en charge l'exploitation des données transmises par le client (celui qui est à l'origine de la requête HTTP)

TIP: Teminologie : les méthodes associées à des _Routes_ dans une classe _Controller_ sont appelées *_méthodes d'action_*. Par extension, on nomme parfois de telles méthodes des *_contrôleurs_*.

== Auto-injection de l'objet Request

Pour accéder aux données transmises avec la requête HTTP,
le contrôleur passera par un objet de type _Request_ (de _HttpFoundation_).

C'est par l'intermédiaire de cet objet, que nous pourrons accéder aux données
de la session utilisateur.

Utilisation d'un objet de la classe `Symfony\Component\HttpFoundation\Request`.

[source, php]
----
use Symfony\Component\HttpFoundation\Request; <1>

[...]

public function index(Request $request) <2>
{
  // exploiter $request
}

[...]
----
<1> un composant du micro-framework
<2> en déclarant un paramètre de type Request, on demande à symfony de nous *auto-injecter* un argument de ce type, parfaitement bien initialisé.

TIP:  Attention, ne pas faire usage de variables super-globales comme GET[], SESSION[], ...


== Données implicites

Ce sont les données transmises par le client, et le serveur,
 dans la partie entête HTTP. Ces données sont accessibles *via* l'objet `Request`
 qui dispose de méthodes bient pratiques pour interroger ces données.


*  getLanguages()
Returns the list of accepted languages ordered by descending quality.

*  getCharsets()
Returns the list of accepted charsets ordered by descending quality.

*  bool isXmlHttpRequest()
Returns true if the request is a XMLHttpRequest.

* ...

voir http://api.symfony.com/4.0/Symfony/Component/HttpFoundation/Request.html[API Request]

== Données explicites

ce sont celles en provenance soit d'un *formulaire (HTML)* soit comme composantes https://en.wikipedia.org/wiki/Query_string[QueryString] de l'*URL*.

=== via un formulaire

[source, php]
----
    // obtenir une valeur transmises par POST d'après sa clé
    $request->request->get('idproduit'); <1>

    // obtenir une instance de UploadedFile identifiée par foo
    $request->files->get('foo');
----

<1> C'est via l'attribut `request`, de l'objet référencé par `$request` (à ne pas confondre) que le contrôleur aura accès aux données passées par `POST`.

=== Cas des arguments passés dans l'url

[source, php]
----
 // retrieves GET variables respectively
    $request->query->get('x', 66); <1> <2>
----

<1> C'est via l'attribut `query`, de l'objet référencé par `$request`, que le contrôleur aura accès aux données passées par `GET`.
 Par exemple, les données transmises en arguments de l'url (`?a=b&x=42`).

<2> La méthode `get` prend en premier argument la *clé* (ici `a` ou `x`), le deuxième étant une *valeur par défaut*.


=== Cas de valeurs incluses dans l'url même

[source, php]
----
 /**
     * Matches /blog/*
     *
     * @Route("/blog/{slug}", name="blog_show")  <1>
     */
    public function show($slug) { ... } <2>
----

<1> La route contient une partie variable, représentée par un paramètre placé en `{  }` (ici _slug_). Exemples d'arguments : `/blog/usecase1` ou `/blog/usecase2`.
<2> Reprise de la partie variable de l'url comme *paramètre* de la méthode (attention, même nom que le paramètre de route)

Il est dans ce cas très facile de récupérer la valeur en question, car elle est passée automatiquement à la méthode !

Plus d'infos sur l'exploitation des valeurs d'entrée :

* https://symfony.com/doc/current/routing.html

avec des exemples de redirection :

* https://symfony.com/doc/current/controller.html

== TP - Le contrôleur et la vue (initiation)

WARNING: Attention à bien respecter les conventions de nommage :
      http://symfony.com/doc/current/contributing/code/standards.html

[TIP]
====
Pour ce TP, vous pouvez choisir d'utiliser le serveur HTTP intégré à PHP en le lançant en ligne de commande.

`php bin/console server:run`

Dans ce cas, il vous faudra tester vos routes ainsi :

`http://127.0.0.1:8000/lucky/number`
====

====
[start=1]
. Ajouter un nouveau controller nommé _IndexController_ disposant d'une méthode nommée _indexAction_.
   Faire en sorte que l'index présente le message « Hello world ! » à l'utilisateur
  (travail sur vue twig associée)
====

[start=2]
====
[start=2]
. Ajouter la méthode d'action _helloAction_ ci-dessous, qui reçoit en paramètre
  un nom, et retourne, via une vue twig, le message « Hello <nom> !» (où <nom>
  est l'argument reçu)

[source,php]
----
  /**
  * @Route("/hello/{nom}", name="app_hello")
  */
  public function helloAction($nom) {
    return $this­>render('index/hello.html.twig', array('nom' => $nom));
  }
----

Faire en sorte que le nom soit présenté à l'utilisateur en majuscule (voir : https://twig.symfony.com/doc/2.x/templates.html)
====

====
[start=3]
. Modifier la méthode d'action helloAction afin que, si le nom transmis est de
  la forme _prenom*nom_ (prénom[étoile]nom), le message soit présenté  selon
  l'exemple ci-dessous : http://localhost:8000/hello/django*reinhardt

=> à vous de déterminer le travail qui devra être réalisé côté contrôleur et côté logique de présentaiton (twig)

image:hello-django.png[hello-django, caption="http://localhost:8000/hello/django*reinhardt"]

WARNING: si aucune étoile n'est présente dans la dernière partie de l'url,
le fonctionnement de `helloAction` devra rester conforme à l'attendu de la question précédente.
====

====
[start=4]
. Modifier le controleur de sorte que si aucun nom n'est passé à hello, le
message 'Hello Inconnu !' est présenté. (voir le concept de *valeur par défaut* pour le paramètre)
====

====
[start=5]
.  Ajouter une nouvelle méthode d'action liée à la route
_/hello/prenom/nom_

Attention contrainte ! : cette méthode devra réutiliser la vue de la méthode
d'action de la route `/hello` (conforme modifiée en question 3 de ce TP)
... et montrera donc le prénom et nom comme précédemment (Ref. à django Reinhardt) car c'est
la même vue.
====

====
[start=6]
. Ajouter un *message flash* (concept à étudier !), qui affiche un message de bienvenue à
l'utilisateur lors de *sa première* sollicitation de l'action _hello_ (pour une même instance de son navigateur). Conseil : Afficher dans un premier temps le message, puis mettre sous condition la création du message en gérant une donnée de session utilisateur.


TIP:  l'objet Session peut être retrouvé via un objet Request que l'on déclare
en paramètre d'une méthode d'action et qui sera automatiquement
« injecté » (passé) par le contrôleur principal de symfony.
====
